func (h *InfoHandler) InitVideoConcat(ctx *gin.Context) {
	// pathStream := "971254691"
	// startDatetime := "2022-05-20 14:12:29.222524+03"
	// durationRecord := 10

	mockVidPath := "123"

	tempDirPath := "./tmp"
	pathsFilePath := tempDirPath + "/" + mockVidPath + ".txt"
	outputVideo := "./videos/qwerty.mp4"

	// paths, err := h.useCase.GetVideoPaths(pathStream, startDatetime, durationRecord)
	// if err != nil {
	// 	log.Println("cannot get video paths from db. error:", err)
	// 	return
	// }

	h.scfg.ConcatStreamPaths = map[string]*[]string{}

	// if _, found := h.scfg.ConcatStreamPaths[pathStream]; !found {
	// 	h.scfg.ConcatStreamPaths[pathStream] = *paths
	// }

	a := []string{
		"/home/stroymaster01/go/src/github.com/mikerumy/vhosting/videos/1_printer.mp4",
		"/home/stroymaster01/go/src/github.com/mikerumy/vhosting/videos/2_restoration.mp4",
		"/home/stroymaster01/go/src/github.com/mikerumy/vhosting/videos/3_styopa.mp4",
	}

	if _, found := h.scfg.ConcatStreamPaths[mockVidPath]; !found {
		h.scfg.ConcatStreamPaths[mockVidPath] = &a
	}

	cmd := exec.Command("./catvid", "-p", pathsFilePath, "-o", outputVideo)
	if err := cmd.Run(); err != nil {
		log.Println("cannot execute catvid binary file. error:", err)
	}

}

func (h *InfoHandler) InitVideoSending(ctx *gin.Context) {
	url := "http://10.100.100.60:8654/api/idRequest"
	method := "POST"
	vidPath := "./tmp/videoplayback.mp4"

	payload := &bytes.Buffer{}
	writer := multipart.NewWriter(payload)
	_ = writer.WriteField("id", "123")
	file, errFile2 := os.Open(vidPath)
	defer file.Close()

	part2,
		errFile2 := writer.CreateFormFile("file", filepath.Base(vidPath))
	_, errFile2 = io.Copy(part2, file)
	if errFile2 != nil {
		fmt.Println(errFile2)
		return
	}

	err := writer.Close()
	if err != nil {
		fmt.Println(err)
		return
	}

	client := &http.Client{}
	req, err := http.NewRequest(method, url, payload)

	if err != nil {
		fmt.Println(err)
		return
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())
	res, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(body))
}

// =========================================

// =========================================